1、将抓取方式由广度优先改为深度优先。原因如下：
	a、广度优先按照所编写的规则由上到下分步执行，request请求、源码的正则匹配和结果的输出分割少有交集的三部分依次执行。
		（注：request请求和源码的正则匹配有交集，但由于源码的正则匹配大部分集中在所要遍历的树的叶子上，所以交集部分也很少）
		因此在抓取的各个阶段对计算机各资源的利用非常集中（一开始在网络‘request请求’，之后在cpu‘源码的正则匹配’，最后是I/O‘输出结果’），
		造成效率瓶颈。
	b、深度优先则不存在a中提到的问题，在抓取过程中对各计算机资源的利用非常均衡。
	c、广度优先在输出结果之前，所有的中间匹配结果都存储在内存中，对内存的要求高，限制了抓取结果的规模。
	d、深度优先在遍历到叶子节点后，即将该结果输出到文件中，可释放内存，对内存要求不高，抓取结果规模没有限制。
	e、广度优先在最后一步输出结果，在输出结果之前很难确定抓取规则正确与否，且中途如出意外（譬如：断网）将前功尽弃。
	f、深度优先在每得到一个结果即输出，在抓取结束前可以依据此部分结果初步确定抓取规则的正误，且抓取期间如出意外，也可以将发生意外时
		的程序状态保存，之后可以从断点处补充抓取未完成部分（虽然广度优先也可以补充抓取，但要保存的中间状态数据极多，不可取）。
	g、广度优先是对目标树层层遍历，在未到达最后一层时，无法估算出叶子的数目，也就无法估算出抓取进度。
	h、深度优先则可以由树根很快遍历到树叶，又由于要抓取的大多数树状结构中各兄弟节点的子节点数大多相近，所以在遍历到第一个叶子节点时，即
		可以初步估算出所有叶子节点数，随着遍历的叶子数目越来越多，估算就越准确。知道叶子节点总数就可以很容易估算出抓取进度了。
		（抓取遍历的树结构越对称，估算就越准确）
	
	多线程深度优先抓取的设计（n个线程）：
		1、先广度遍历目标树，当兄弟节点数目target大于线程数n时，即开始多线程的深度遍历，当完成一组深度遍历后，如果剩下的兄弟节点数target仍然
			大于线程数n，则再进行一组多线程的深度遍历，如此多次。
		2、当兄弟节点数target小于线程数n时，对target个兄弟节点进行广度遍历，直到target数大于线程数n时，再重复1步骤。
		3、当所有的叶子节点被遍历后，程序结束。